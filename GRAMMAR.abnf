; Follows ABNF syntax as defined here: http://www.rfc-editor.org/rfc/rfc5234.txt
; Core Rules are used here

; Any rule whose name is in upper camel case is a token definition
;
; Any rule whose name is in capitals (w/ or wo/ dashes) is an extension to the core rules
;
; Any rule whose name is in dash-case (e.g. dash-case) is an expression definition

UALPHA                              = %x41-5A ; A-Z

WSP-ANY                             = *WSP

WSP-CRLF-ANY                        = WSP-ANY / *CRLF

;;;
;;;
;;; RULES OF PROPOSITIONAL LOGIC
;;;
;;;
;;;; Tokens
;;;
GrouperOpeningToken                 = "("

GrouperClosingToken                 = ")"

LogicalConjunctionToken             = "&"

LogicalNegationToken                = "~"

LogicalDisjunctionToken             = %x2228 ; where %x2228 = ∨

LogicalConditionalToken             = %x2283 ; where %x2283 = ⊃

StatementSeparatorToken             = ","

ConclusionIndicatorToken            = ".:."

SetOpeningToken                     = "{"

SetClosingToken                     = "}"

SimpleStatementToken                = UALPHA [ SubscriptNumberToken ]

; defines, in subscript, any positive integer (leading zeros not allowed)
SubscriptNumberToken                = (%x2081-2089 [ SubscriptNumberToken ])
                                    / (SubscriptNumberToken %x2080 [ SubscriptNumberToken ])

;;;
;;;; Expressions
;;;
simple-statement                    = SimpleStatementToken
                                    / (GrouperOpeningToken WSP-ANY SimpleStatementToken WSP-ANY GrouperClosingToken)

logical-conjunction                 = (GrouperOpeningToken WSP-ANY statement WSP-ANY LogicalConjunctionToken WSP-ANY statement WSP-ANY GrouperClosingToken)

logical-negation                    = (GrouperOpeningToken WSP-ANY LogicalNegationToken WSP-ANY statement WSP-ANY GrouperClosingToken) ; groupers aren't needed as it's unambiguous

logical-disjunction                 = (GrouperOpeningToken WSP-ANY statement WSP-ANY LogicalDisjunctionToken WSP-ANY statement WSP-ANY GrouperClosingToken)

logical-conditional                 = (GrouperOpeningToken WSP-ANY statement WSP-ANY LogicalConditionalToken WSP-ANY statement WSP-ANY GrouperClosingToken)

complex-statement                   = logical-conjunction
                                    / logical-negation
                                    / logical-disjunction 
                                    / logical-conditional

statement                           = simple-statement / complex-statement

statement-list                      = statement 
                                    / (statement WSP-ANY StatementSeparatorToken WSP-CRLF-ANY statement-list)

argument-conclusion                 = ConclusionIndicatorToken WSP-ANY statement

argument-premise-list               = statement-list

argument                            = argument-premise-list WSP-CRLF-ANY argument-conclusion

statement-set                       = SetOpeningToken WSP-CRLF-ANY statement-list WSP-CRLF-ANY SetClosingToken

;;; rpl-rs specific rule
input                               = argument / statement-set

;;;
;;;
;;; RULES OF PROPERTY PREDICATE LOGIC
;;;
;;;
;;;; Tokens
;;;
SingularTermToken                   = %x61-77 [ SubscriptNumberToken ] ; a-w [ SubscriptNumberToken ]

ExistentialQuantifierToken          = %x2203 ; where %x2203 = ∃

UniversalQuantifierToken            = %x2200 ; where %x2200 = ∀

;;;
;;;; Expressions
;;;
property-predicate                  = UALPHA [ SubscriptNumberToken ] %x00B9 ; where %x00B9 = ¹  (superscript numeral '1')

singular-statement                  = (property-predicate SingularTermToken) 
                                    / (GrouperOpeningToken WSP-ANY property-predicate SingularTermToken WSP-ANY GrouperClosingToken)

simple-statement                    =/ singular-statement

predicate                           = simple-predicate / compound-predicate

simple-predicate                    = property-predicate

compound-predicate                  = 
                                    ; (α & β)
                                      (GrouperOpeningToken WSP-ANY predicate WSP-ANY LogicalConjunctionToken WSP-ANY predicate WSP-ANY GrouperClosingToken) 
                                    ; ~α
                                    / (GrouperOpeningToken WSP-ANY LogicalNegationToken WSP-ANY predicate WSP-ANY GrouperClosingToken)
                                    ; (α ∨ β)
                                    / (GrouperOpeningToken WSP-ANY predicate WSP-ANY LogicalDisjunctionToken WSP-ANY predicate WSP-ANY GrouperClosingToken)
                                    ; (α ⊃ β)
                                    / (GrouperOpeningToken WSP-ANY predicate WSP-ANY LogicalConditionalToken WSP-ANY predicate WSP-ANY GrouperClosingToken)

existential-quantifier-statement    = ExistentialQuantifierToken predicate

universal-quantifier-statement      = UniversalQuantifierToken predicate

complex-statement                   =/ existential-quantifier-statement 
                                    / universal-quantifier-statement
                                 
;;;
;;;
;;; RULES OF RELATIONAL PREDICATE LOGIC
;;;
;;;
;;;; Tokens
;;;
; defines, in superscript, any positive integer (leading zeros not allowed)
SuperscriptNumber                   = ((%x00B9 / %x00B2-00B3 / %x2074-2079) [ SuperscriptNumber ])  ; 1-9
                                    / (SuperscriptNumber %x2070 [ SuperscriptNumber ]) ; 0

Variable                            = %x78-7A [ SubscriptNumberToken ] ; x-z [ SubscriptNumberToken ]

;;;
;;;; Expressions
;;;
relation                            = UALPHA [ SubscriptNumberToken ] SuperscriptNumber

simple-predicate                    =/ relation ; extends existing definition to allow any value for superscript (positive integer, no leading zeros)

; singular-statement: any number of singular terms allowed here (except 0). 
; Because the number of singular terms = degree of relation cannot be well defined in a 
; context-free grammar, I'll leave only a note here and make sure the parser does its job.
singular-statement                  =/ relation 1*SingularTermToken

; Same thing that was said for singular-statement is said here.
; Context-free grammars cannot correctly define the need for all predicates of degree >=1 to bind to the variable
existential-quantifier-statement    =/ (ExistentialQuantifierToken WSP-ANY Variable WSP-ANY predicate)
                                    / (GrouperOpeningToken WSP-ANY ExistentialQuantifierToken WSP-ANY Variable WSP-ANY GrouperClosingToken WSP-ANY predicate)

universal-quantifier-statement      =/ (UniversalQuantifierToken WSP-ANY Variable WSP-ANY predicate)
                                    / (GrouperOpeningToken WSP-ANY UniversalQuantifierToken WSP-ANY Variable WSP-ANY GrouperClosingToken WSP-ANY predicate)