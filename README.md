# logic-rs
[![Build Status](https://travis-ci.org/ixjf/logic-rs.svg?branch=master)](https://travis-ci.org/ixjf/logic-rs)
[![codecov](https://codecov.io/gh/ixjf/logic-rs/branch/master/graph/badge.svg)](https://codecov.io/gh/ixjf/logic-rs)

A parser of relational predicate logic and truth tree solver.

The website for this library, which can be found [here](https://ixjf.github.io/logic-rs/),
provides a full-featured demo of it.

logic_rs is heavily influenced by the book _Meaning and Argument:
An Introduction to Logic Through Language_, by Ernest Lepore and Sam Cumming, trying
to follow as closely as possible its grammar and rules.

It uses separate syntax for statement sets, arguments, and sole statements, and so
can automatically generate and analyse truth trees accordingly.

**Note: logic_rs currently doesn't support identity statements. It is planned
for the future, however.**

# Usage
Validating some formula is as simple as:

```rust
match parse_input("(∀x)(B¹x ⊃ (L²xm ⊃ L²bx))") {
    Ok(input_kind) => {
        // Input is a well-formed formula
    },
    Err(parse_err) => {
        // Input is **not** a well-formed formula
    }
}
```

And proving that the input above is a sole statement and that that statement is a contingency
is just as simple:
```rust
match parse_input("(∀x)(B¹x ⊃ (L²xm ⊃ L²bx))") {
    Ok(input_kind) => match input_kind {
        InputKind::Statement(st) => {
            let (
                is_contingency,
                truth_tree_statement,
                truth_tree_negation_of_stmt
                ) = st.is_contingency();
            
            assert_eq!(is_contingency, true);
        },
        _ => assert!(false)
    },
    Err(parse_err) => assert!(false)
}
```

The same process would be used to test whether the statement is a contradiction or a contingency, as well
as to test the consistency of a statement set, or the formal validity of an argument. 


`truth_tree_statement` and `truth_tree_negation_of_stmt` are the resulting truth trees generated by the algorithm for an initial
statement equal to the input, and for the negation of that statement, respectively. If the truth tree
for the statement closed, it would be proved that the statement is a contradiction, since it's not possible
for it to be true in any case; if the truth tree for the negation of the statement closed, it would be
proved that the statement is a tautology, since the negation of a tautology is a contradiction.
In this case, the initial statement is a contingency, so if we called the method `is_open` on each
truth tree, we would find that both were open, thus corroborating our knowledge.


For more details, see the documentation at [docs.rs](https://docs.rs/logic_rs/0.1.0).

# Language and Truth Tree Algorithm
logic_rs allows an infinite universe of discourse and does not place any other restrictions on the set
of allowed input sets. This means that inputs that can lead to infinite trees _are_ allowed,
and will make the algorithm get stuck in an infinite loop. It's still being considered what the best
course of action in relation to this is, but you can see on the documentation page (linked right above) 
where I hope to go.

I can guarantee, however, _unless there is some bug_, that the algorithm will always correctly classify
_all_ unsatisfiable set of statements. So, if the algorithm _does_ get into an infinite loop, then
it is certain that the initial set of statements is satisfiable.