DONE A tree with a main trunk/branch

DONE Each rule may divide the current branch into two or more new branches, or add to the existing branch

DONE Need a stack for existing singular terms in each branch

DONE Each statement can only have one ruled applied. That means that when rules are applied to a group of statements, only the resulting statements (i.e. those that aren't marked done) are reprocessed until they're all atomic(!) or require branching

DONE When a rule is applied to a statement, it is marked as done, except for UQ

DONE When a rule is applied, the resulting statement(s) must keep track of the rule that was applied, and what statement it resulted from

DONE Rules are applied in a specific order: non-branching rules before branching rules, QE before EQ, EQ before UQ

DONE Every time a rule is processed and the resulting statement is atomic, check for contradictions from that branch upwards to the root of the tree



enum BranchStatus {
    Open,
    Closed
}

struct Branch {
    pub statements: Vec<StatementData>,
    pub status: BranchStatus
}


Node<Branch>

Node can have multiple children, can have a parent


Vec<SingularTerm> = stack


We need a is_atomic function that returns true whenever a statement is atomic (a simple statement or a negation of one), and false whenever it isn't

We need to know when a UQ rule should be processed. How do I know a new singular term was added to the stack? Add a Vec<SingularTerm> to the UQ rule to know which singular terms it was instantiated with already. Then it's as easy as checking if statement.terms_instantiated.each not in singular_term_stack => process, else skip


StatementData needs this info:
    - Whether a rule has been applied to it, and therefore needs no further processing (i.e. checkbox), and in which branch it was
    - The singular terms that this rule was instantiated for already, if it's a universal statement, with a reference to a branch

    - Reference to the statement that this was derived from
    - The rule that was applied if it was derived

    - The statement itself


What about sibling branches instantiating a new singular term of the same type? How can the algorithm know from which branch a singular term was used with a UQ rule? Associate each singular term with a branch, then in the apply_uq_rule check for the first singular term in the stack that either hasn't been instantiated at all, or hasn't been instantiated in any of ancestor() branches)

How can I be modifying the iteration in compute_branch while iterating over it...? Well, there's only one mutable borrow at any one time, and iterators are lazy, i.e. we don't build a fixed list of statements to iterate over beforehand, so that might work. We'll see.

Problems: 1) compute_branch is iterating over the children of an ancestor branch, and we need to add a child to the current branch, which may or may not be the same one we're iterating over
          2) we need to modify statement_data in each rule function, but if we borrow the branch mutably, then we can't modify it
          3) DONE when branching rules are applied, compute_branch will apply remaining rules of the parent branch to one of the branches, but the remaining children branches won't because they'll already have been applied to one - we can fix that by adding a reference to the branch where a rule was processed. then it's a matter of checking if a rule has been processed in one of the ancestor branches





compute_branch(branch, singular_terms_stack):
    // Priority is important, can't have a parent branch changing after 
    // a child branch has been processed
    // hence branching rules are ALWAYS processed last

    // Don't think we'll be able to do this exactly. Can't pass 'self' because multiple mutable borrows
    // Probably have to make apply_*_rule associated functions instead
    let rules: Vec<fn() -> T> = vec![
        |statement_data, _, _| apply_qe_rule(statement_data),
        |statement_data, singular_terms_stack, _| apply_eq_rule(statement_data, singular_terms_stack),
        |statement_data, singular_terms_stack, branch| apply_uq_rule(statement_data, singular_terms_stack, branch),
        |statement_data, _, _| apply_conjunction_rule(statement_data),
        |statement_data, _, _| apply_double_negation_rule(statement_data),
        |statement_data, _, _| apply_negation_of_disjunction_rule(statement_data),
        |statement_data, _, _| apply_negation_of_conditional_rule(statement_data),
        |statement_data, _, _| apply_disjunction_rule(statement_data),
        |statement_data, _, _| apply_conditional_rule(statement_data),
        |statement_data, _, _| apply_negation_of_conjunction_rule(statement_data),
    ];

    'outer: for rule_fn in rules:
        for all statements in (branch.ancestors_including_this().undone && not_done_in_one_of_ancestor_branches):
                if is_atomic(statement_data.statement) and compare_upwards_is_contradiction(statement_data.statement) then
                    branch.status = BranchStatus::Closed;
                    break 'outer;
                end

                local res = (*rule_fn)(statement_data, singular_terms_stack, branch)

                if let Some(RuleCreateKind::NewBranches) = res.kind then
                    foreach statement in res.statements:
                        let new_branch = new Branch({statement})
                        branch.add_child(new_branch)
                    
                        compute_branch(new_branch, singular_terms_stack.clone()) // this will apply any remaining branching rules from the parent branch
                                                   // so it'll never be that this for loop will end and the algorithm will
                                                   // apply other UQ rules, branching as a child of 'branch' rather than the existing children branches
                                                   // branch 1:
                                                   // i.e. A -> B
                                                   //      C -> D
                                                   // when the conditional rule is applied to the first statement, it'll branch off
                                                   // to say, branches 2 and 3
                                                   // and immediately compute any remaining statements from the ancestors
                                                   // meaning the branches from C -> D will appear in the new branches 2 and 3
                                                   // and not in branch 1
                    end
                else if let Some(RuleCreateKind::Merge) = res.kind then
                    (*branch.borrow_mut()).statements.push_back(statement_data)
                end
        end
    end
end

RuleResultKind = {
    NewBranches,
    MergeToExisting
}

struct RuleApplyResult {
    kind: RuleResultKind,
    statements: Vec<StatementData>
}

apply_qe_rule(statement_data, branch):
    // ...
    statement_data.is_done = (true, branch)
    return { kind = Some(RuleCreateKind::MergeToExisting), statements = new_statements.map(|x| build_statement_data(derived_from: statement_data, rule: rule, statement: new_statement)).collect() }

...

apply_uq_rule(statement_data, singular_terms_stack, branch):
    // ...
    singular_terms = singular_terms_stack.find_all(|x| statement_data.applied_to.is_none() || !statement_data.applied_to.unwrap().iter().any(|y| y.0 == **x && branch.ancestors().any(|z| z == y.1)))

    if !singular_terms return { kind = None } end

    // ...
    let statements
 
    foreach term in singular_terms:
        statement_data.applied_to.push_back(singular_term)
        statements.push(build_statement_data(derived_from: statement_data, rule: rule, statement: new_statement))
    end

    return { kind = Some(RuleCreateKind::NewBranches, statements = new_statements }

...