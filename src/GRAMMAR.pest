// TODO: Support for groupers, nested quantifiers!!! (can't have quantifier
// with existing variable as well! and a quantifier statement's predicate
// must necessarily have that variable bound in at least one place)

// This specification does not take into account these:
// 1. Degree of predicate matching number of terms
// 2. Binding correct variable to predicate in quantifier
// 3. (not yet implemented at all) Operator precedence
// For all else, if it doesn't match wiki/Language, it's
// a bug

WHITESPACE = _{ " " | NEWLINE | "\t" }

input = { SOI ~ (statement_set | argument) ~ EOI }

//grouper = { grouper_opening ~ formula ~ grouper_closing }
grouper_opening = _{ "(" }
grouper_closing = _{ ")" }

statement_separator = _{ "," }

statement_set_opening = _{ "{" }
statement_set_closing = _{ "}" }
statement_set = { 
    statement_set_opening ~ 
    statement ~ (statement_separator ~ statement)* ~ 
    statement_set_closing 
}

conclusion_indicator = _{ ".:." }
premise = { statement }
conclusion = { statement }
argument = {
    premise ~ (statement_separator ~ premise)* ~
    conclusion_indicator ~
    conclusion
}

statement = { complex_statement | simple_statement }
complex_statement = { 
    logical_conjunction | 
    logical_negation | 
    logical_disjunction | 
    logical_conditional |
    existential_statement |
    universal_statement
}

conjunction_connective = _{ "&" }
logical_conjunction = { 
    grouper_opening ~ 
    statement ~ 
    conjunction_connective ~ 
    statement ~ 
    grouper_closing 
}

negation_connective = _{ "~" }
logical_negation = { negation_connective ~ statement }

disjunction_connective = _{ "\u{2228}" }
logical_disjunction = { 
    grouper_opening ~ 
    statement ~ 
    disjunction_connective ~ 
    statement ~ 
    grouper_closing 
}

conditional_connective = _{ "\u{2283}" }
logical_conditional = { 
    grouper_opening ~ 
    statement ~ 
    conditional_connective ~ 
    statement ~ 
    grouper_closing 
}

subscript_number = { !"\u{2080}" ~ ('\u{2081}'..'\u{2089}'+ ~ "\u{2080}"*)+ }
simple_statement_letter = @{ ASCII_ALPHA_UPPER ~ subscript_number? }
simple_statement = {
    singular_statement |
    simple_statement_letter
}

singular_term = @{ 
    (&(!('x'..'z')) ~ ASCII_ALPHA_LOWER) ~ 
    subscript_number? 
}

variable = @{ 'x'..'z' ~ subscript_number? }

term = { singular_term | variable }

superscript_number = @{ 
    !"\u{2070}" ~ (
        ("\u{00B9}" | '\u{00B2}'..'\u{00B3}' | '\u{2074}'..'\u{2079}')+ ~ 
        "\u{2070}"*
    )+ 
}
predicate_letter_inner = @{ ASCII_ALPHA_UPPER ~ subscript_number? }
predicate_letter = ${
    predicate_letter_inner ~
    superscript_number
}

singular_statement = ${ predicate_letter ~ singular_term+ }

predicate = { compound_predicate | simple_predicate }

simple_predicate = ${ 
    predicate_letter ~ 
    (singular_term* ~ variable ~ singular_term*)+ 
}

conjunctive_predicate = { 
    grouper_opening ~ 
    predicate ~
    //(predicate | existential_statement | universal_statement) ~ 
    conjunction_connective ~ 
    predicate ~
    //(predicate | existential_statement | universal_statement) ~ 
    grouper_closing 
}
negative_predicate = {
    negation_connective ~ 
    // (predicate | existential_statement | universal_statement)
    predicate
}
disjunctive_predicate = {
    grouper_opening ~ 
    // (predicate | existential_statement | universal_statement) ~ 
    predicate ~
    disjunction_connective ~ 
    // (predicate | existential_statement | universal_statement) ~ 
    predicate ~
    grouper_closing
}
conditional_predicate = {
    grouper_opening ~ 
    // (predicate | existential_statement | universal_statement)~ 
    predicate ~
    conditional_connective ~ 
    // (predicate | existential_statement | universal_statement) ~ 
    predicate ~
    grouper_closing
}
compound_predicate = { 
    conjunctive_predicate |
    negative_predicate |
    disjunctive_predicate |
    conditional_predicate
}

existential_quantifier = _{ "\u{2203}" }
existential_statement = { 
    existential_quantifier ~ 
    variable ~ 
    predicate 
}

universal_quantifier = _{ "\u{2200}" }
universal_statement = { 
    universal_quantifier ~ 
    variable ~ 
    predicate 
}
